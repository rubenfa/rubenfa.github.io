---
layout: post
title:  Windows Phone. Binding. Un ejemplo práctico.
redirect_from:
  - /post/70479779067/windows-phone-binding-un-ejemplo-práctico.html
---


<p><a href="http://www.charlascylon.com/post/69575487235/windows-phone-introducion-mvvm-y-binding" title="Enlace a patrón MVVM en Windows Phone">Hace unos días</a> os contaba qué es el <strong>patrón MVVM</strong> y cómo se utiliza. Así que hoy vamos a ha ver un ejemplo sencillo de como podemos utilizar el enlace de datos o binding en nuestra aplicación <strong>Windows Phone</strong> para aprovecharnos de las ventajas de usar este patrón. El ejemplo es bastante sencillo, pero será suficiente para ilustrar como enlazar propiedades y colecciones con nuestra vista <em>XAML</em>.<br/></p>

<blockquote><strong>Nota</strong>: el ejemplo lo podéis descargar desde <a href="https://github.com/rubenfa/BindingExampleApp" title="Enlace al código de ejemplo.">aquí</a>. El proyecto está desarrollado para <strong>Windows Phone 8</strong>, así que necesitaréis <strong>Windos Phone SDK </strong>que podéis descargar desde <a href="http://developer.windowsphone.com/en-us/downloadsdk" title="Enlace a descarga de SDK's de Windows Phone">aquí</a>. <br/></blockquote>

<h3>Creando el modelo</h3>

<p>Está claro que cuándo creamos una aplicación para <strong>Windows Phone</strong> lo más normal es necesitar una lógica de negocio compleja. Para recuperar nuestros datos necesitaremos consultar un servicio web, una API u otros servicios externos. Pero como todas esas operaciones están alejadas del objetivo de esta entrada, nuestro modelo de datos va a ser muy sencillo. <br/><br/> Nuestra aplicación mostrará datos de una línea de teléfono (número y operador), así como una lista con las últimas llamadas de esa línea. El modelo es el siguiente:</p>

<div class="hiddenCode">public class Llamada<br/> {<br/>         public string Contacto { get; set; }<br/>         public string NumeroTlf { get; set; }<br/>         public string Tipo { get; set; }<br/>         public DateTime Fecha{get;set;}<br/>     }<br/><br/>     public class ListaLlamadas : ObservableCollection&lt;Llamada&gt;<br/>     {<br/>         public void AddLlamada(Llamada llamada)<br/>         {<br/>             this.Add(llamada);<br/>         }<br/>     }<br/><br/>     public class AppModel<br/>     {<br/><br/>         public string NumeroLinea { get; set; }<br/>         public string Operador { get; set; }<br/>         public ListaLlamadas llamadas;<br/>     }</div>

<p><br/><br/> La clase <em>Llamada </em>simplemente contiene las propiedades típicas que se pueden asociar a una lllamada, como número de teléfono, nombre del contacto, el tipo (entrante o saliente) y la fecha. Todas esas llamadas van asociadas a una línea de teléfono, que representa la clase <em>AppModel </em>y que tiene propiedades como el número de línea o el operador. Además esta clase contiene una lista de llamadas, que vamos a ver más en detalle.<br/><br/> Para crear la lista de llamadas, hemos creado la clase <em>ListaLlamadas </em>que hereda de la clase <a href="http://msdn.microsoft.com/es-es/library/ms668604%28v=vs.110%29.aspx" title="Enlace a ObservableCollection">ObservableCollection</a> ¿Por qué hemos hecho esto y no hemos usado una clase List? Pues porque esta clase implementa la interface <em> INotifyCollectionChanged</em>, lo que hace que se lance un evento <em>CollectionChanged</em> cada vez que se hacen cambios en la colección. <br/><br/> Aunque todavía no lo vamos a usar en este ejemplo, este evento nos ayudará a realizar un binding de la colección, de manera que la vista cambie cuándo se añaden o eliminan elementos de la lista de llamadas. Así que por ahora, nos quedamos con que es una lista a la que se le añaden las llamadas.<br/><br/> En el modelo también hemos implementado una clase estática, que contiene el método <em>getLineaModel</em>, que lo único que hace es generar un objeto <em>AppModel</em>, incluyendo una lista de llamadas de ejemplo.<br/></p>

<h3>Creando la vista-modelo</h3>

<p>Nuestra vista-modelo se llamará <em>MainViewModel</em>, de la misma manera que nuestra página <em>XAML</em>.</p>

<div class="hiddenCode">  public class MainViewModel : INotifyPropertyChanged<br/>         {<br/>             private string _NumeroLinea;<br/><br/>             public string NumeroLinea<br/>             {<br/>                 get<br/>                 {<br/>                     return _NumeroLinea;<br/>                 }<br/>                 set<br/>                 {<br/>                     if (value != _NumeroLinea)<br/>                     {<br/>                         _NumeroLinea = value;<br/>                         NotifyPropertyChanged(&ldquo;NumeroLinea&rdquo;);<br/>                     }<br/>                 }<br/>             }<br/><br/>             private string _Operador;<br/><br/>             public string Operador<br/>             {<br/>                 get<br/>                 {<br/>                     return _Operador;<br/>                 }<br/>                 set<br/>                 {<br/>                     if (value != _Operador)<br/>                     {<br/>                         _Operador = value;<br/>                         NotifyPropertyChanged(&ldquo;Operador&rdquo;);<br/>                     }<br/>                 }<br/>             }<br/><br/>             public event PropertyChangedEventHandler PropertyChanged;<br/>             private void NotifyPropertyChanged(String propertyName)<br/>             {<br/>                 PropertyChangedEventHandler handler = PropertyChanged;<br/>                 if (null != handler)<br/>                 {<br/>                     handler(this, new PropertyChangedEventArgs(propertyName));<br/>                 }<br/>             }<br/><br/>         }</div>

<p><br/><br/> Esta clase es bastante sencilla y tan solo presenta dos propiedades llamadas <em>NumeroLinea</em> y <em>Operador, </em>ambas del tipo string.  Estas propiedades tienen sus correspondientes <em>set</em> y <em>get</em> para establecer los valores. Y es en el <em>set</em> de cada propiedad, dónde encontramos el meollo del asunto. Cada vez que se cambia el valor de una de las propiedades se ejecuta el método <em>NotifyPropertyChanged</em> que lanzará un evento <em>PropertyChanged</em> con el nombre de la propiedad que ha sido cambiada. Este evento lo tenemos que lanzar porque nuestra clase implementa la interface <em>INotifyPropertyChanged</em>. <br/><br/> De esta manera, cuando una propiedad cambia, se lanza un evento de este tipo, y si tenemos enlazada la propiedad en la vista, la vista cambiará automáticamente.</p>

<h3>Creando la vista</h3>

<p>La vista tiene bastante código, así que no la voy a poner entera, si no por partes. <br/><br/> Lo primero que vamos a ver, es como hemos enlazado las dos propiedades que están en nuestra vista-modelo con nuestra vista. En este caso, las hemos enlazado a dos elementos <em>TextBox</em>.</p>

<div class="hiddenCode">&lt;StackPanel Orientation=&ldquo;Vertical&rdquo; Grid.Row=&ldquo;0&rdquo;&gt;<br/>                 &lt;TextBlock&gt;Línea de teléfono&lt;/TextBlock&gt;<br/>                 &lt;TextBox Text=&ldquo;{Binding NumeroLinea}&rdquo;&gt;&lt;/TextBox&gt;<br/>                 &lt;TextBlock&gt;Operador&lt;/TextBlock&gt;<br/>                 &lt;TextBox Text=&ldquo;{Binding Operador}&rdquo;&gt;&lt;/TextBox&gt;<br/>   &lt;/StackPanel&gt;</div>

<p><br/> Si os fijaís en el atributo <em>Text </em>de cada <em>TextBox</em>, hemos añadido un <em>&ldquo;{Binding NombrePropiedad}&rdquo;</em>. Ahí estamos especifícando que ese campo está enlazado con la propiedad <em>NumeroLinea </em>de nuestro objeto <em>View-Model</em>. Cuándo se lance un evento <em>PropertyChanged</em>, la vista lo capturará, y modificará el texto del <em>TextBox </em>correspondiente. <br/><br/> Ya podéis ver, que hacer un binding de propiedades es un juego de niños. Ahora vamos a crear un enlace a una lista, que aunque no es difícil, tiene un poquito más de historia. La parte del XAML que nos importa es la siguiente.<br/></p>

<div class="hiddenCode">        &lt;ListBox Name=&ldquo;ListaLLamadas&rdquo; Grid.Row=&ldquo;1&rdquo; Margin=&ldquo;10,0,0,0&rdquo;&gt;<br/>                 &lt;ListBox.ItemTemplate&gt;<br/>                     &lt;DataTemplate&gt;<br/>                         &lt;StackPanel Orientation=&ldquo;Vertical&rdquo; Margin=&ldquo;0,0,0,10&rdquo;&gt;                                                            <br/>                            &lt;TextBlock Name=&ldquo;contacto&quot;  Text=&rdquo;{Binding Contacto}&ldquo; Foreground=&rdquo;{StaticResource PhoneAccentBrush}&ldquo;&gt;&lt;/TextBlock&gt;<br/>                             &lt;StackPanel Orientation=&quot;Horizontal&rdquo; FlowDirection=&ldquo;LeftToRight&rdquo;&gt;<br/>                                 &lt;TextBlock Text=&ldquo;Teléfono:&rdquo; Margin=&ldquo;0,0,5,0&rdquo; FontSize=&ldquo;15&quot;  Foreground=&rdquo;{StaticResource PhoneDisabledBrush}&ldquo;&gt;&lt;/TextBlock&gt;<br/>                                 &lt;TextBlock Name=&quot;numeroTlf&rdquo; Text=&ldquo;{Binding NumeroTlf}&rdquo; Margin=&ldquo;0,0,10,0&rdquo; FontSize=&ldquo;15&rdquo;&gt;&lt;/TextBlock&gt;<br/>                                 &lt;TextBlock Text=&ldquo;Tipo:&rdquo; Margin=&ldquo;0,0,5,0&rdquo; FontSize=&ldquo;15&rdquo; Foreground=&ldquo;{StaticResource PhoneDisabledBrush}&rdquo;&gt;&lt;/TextBlock&gt;<br/>                                 &lt;TextBlock Name=&ldquo;destino&rdquo; Text=&ldquo;{Binding Tipo}&rdquo; Margin=&ldquo;0,0,10,0&rdquo; FontSize=&ldquo;15&rdquo;&gt;&lt;/TextBlock&gt;                               <br/>                            &lt;/StackPanel&gt;<br/>                             &lt;TextBlock Name=&ldquo;fecha&rdquo; Text=&ldquo;{Binding Fecha, StringFormat=&lsquo;dd-mm-yy, hh:MM:ss&rsquo;}&rdquo; FontSize=&ldquo;15&rdquo;&gt;&lt;/TextBlock&gt;<br/>                         &lt;/StackPanel&gt;                        <br/>                    &lt;/DataTemplate&gt;<br/>                 &lt;/ListBox.ItemTemplate&gt;<br/>             &lt;/ListBox&gt;<br/>  </div>

<p>En este caso, hemos creado un elemento<em> ListBox</em>, cuyo nombre <em>ListaLlamadas</em> es importante recordar, ya que lo usaremos más tarde. Para hacer un binding de una lista, dentro hemos definido  una plantilla para cada elemento de la lista a través de <em>ListBox.ItemTemplate</em>. Dentro de esta etiqueta, especificamos la plantilla que tendrá cada elemento de la lista, la cuál crearemos de forma normal. Vamos, añadiendo <em>Grids</em>, <em>TextBlocks</em>, <em>StackPanel</em> o cualquier elemento que necesitemos en nuestra app <strong>Windows Phone</strong>.<br/><br/> Para especificar los enlaces de datos, lo hacemos de la misma manera que hemos hecho antes con las propiedades. En cada atributo <em>Text</em> de los <em>TextBloc</em>k que queremos enlazar, añadimos un <em>&ldquo;{Binding NombrePropiedad}&rdquo;</em>, lo único que esta vez, los nombres de las propiedades van a ser los mismos que en la clase <em>Llamada</em> de nuestro modelo de datos.<br/><br/> ¿Y con esto ya está?. Pues casi. Ahora lo que tenemos que hacer, es decirle a nuestra vista qué vista-modelo o qué lista de datos, debe utilizar.</p>

<h3>Cargando los datos</h3>

<p>Para decirle a la vista que datos debe utilizar, es decir que objeto vista-modelo, podemos hacerlo directamente con la propiedad <em>DataContext</em> de la vista. Para decirle a la lista que lista de datos contiene los elementos que tiene que representar, podemos utilizar la propiedad <em>ItemSource</em>. Esto lo podemos hacer desde el codebehind de nuestra vista, que en este caso se tiene un nombre tan original como <em>MainPage</em>. Veamos el código:</p>

<div class="hiddenCode">  Models.AppModel CurrentModel = Models.ModelGenerator.getLineaModel();<br/>   ViewModels.MainViewModel CurrentViewModel = new ViewModels.MainViewModel();<br/><br/>   CurrentViewModel.NumeroLinea = CurrentModel.NumeroLinea;<br/>   CurrentViewModel.Operador = CurrentModel.Operador;<br/><br/>   this.DataContext = CurrentViewModel;<br/><br/>   this.ListaLLamadas.ItemsSource = CurrentModel.llamadas;</div>

<p><br/> Como veis la operación es bastante sencilla. Primero creamos un objeto <em>AppModel</em>, que contiene los datos obtenidos de nuestro modelo. Recordad que nuestro modelo es muy sencillo, pero aquí es dónde debería incluirse la lógica de negocio de nuestra aplicación. Esto es, llamadas a <em>Web Services</em>, a <em>APIS</em> o cualquier otra cosa.<br/><br/> También instanciamos un objeto <em>MainViewModel</em>, al cual le asignamos las propiedades <em>NumeroLinea</em> y <em>Operador</em> que hemos obtenido de nuestro modelo. Y para finalizar, utilizamos el objeto <em>DataContext</em> para decirle a la vista que objeto debe utilizar.<br/><br/> Con la lista de llamadas hacemos algo similar, solo que en este caso utilizamos la propiedad <em>ItemsSource</em> del objeto <em>ListaLlamadas</em> Recordad que <em>ListaLlamadas</em> es el nombre que le dimos a la lista en el código <em>XAML</em>.<br/><br/> Y ya está. Si lanzamos la aplicación, veremos algo parecido a esto en nuestro emulador:</p>

<p><img src="http://33.media.tumblr.com/d7da419f4a7a7a4f38d56e30f5cb51b9/tumblr_inline_my1wiqF3Ij1sno6e9.png"/></p>



<h3>Conclusiones</h3>

<p>Realizar un binding o enlace de datos en <strong>Windows Phone</strong> es muy sencillo. Pero es que además de sencillo es muy útil, y mejora la calidad del código de forma exponencial. En el próximo artículo, veremos como enlazar comandos para actualizar nuestros datos.<br/><br/></p>

<hr><hr><p><em>¿Te ha gustado el artículo? No te olvides de hacer +1 en Google+, Me gusta en Facebook o de publicarlo en Twitter. ¡ Gracias !</em></p>

<p>¿Quiéres que te avisemos cuándo se publiquen nuevas entradas en el blog? Suscríbete <a href="feed://www.charlascylon.com/feed.xml">por RSS</a>.<em><a href="http://www.charlascylon.com/p/tutorial-mongodb.html"><br/></a></em></p>
